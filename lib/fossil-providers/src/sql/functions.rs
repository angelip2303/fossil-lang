//! SQL Provider functions
//!
//! Implements the runtime functions generated by the SQL provider.

use fossil_lang::ast::Loc;
use fossil_lang::ir::{Ident, Ir, Polytype, PrimitiveType, Type as IrType, TypeKind as IrTypeKind, TypeVar};
use fossil_lang::error::RuntimeError;
use fossil_lang::passes::GlobalContext;
use fossil_lang::runtime::value::Value;
use fossil_lang::traits::function::{FunctionImpl, RuntimeContext};
use polars::prelude::*;

use super::config::SqlConfig;
use super::connection::{get_runtime, ConnectionPool};
use super::schema::SqlSchema;
use super::streaming::execute_query_to_dataframe;

/// Load function that executes a SQL query and returns results as a LazyFrame
///
/// This function captures the connection string, query, and schema at compile-time.
/// At runtime, it connects to the database and fetches the data.
///
/// Example usage in fossil:
/// ```ignore
/// type Customer = sql<"postgres://localhost/shop", "customers">
/// let customers = Customer::load()
/// ```
pub struct SqlLoadFunction {
    pub config: SqlConfig,
    pub schema: SqlSchema,
    /// The name of the type this function belongs to (e.g., "Customer")
    /// Used to look up the type DefId at signature time
    pub type_name: String,
}

impl FunctionImpl for SqlLoadFunction {
    fn signature(
        &self,
        ir: &mut Ir,
        _next_type_var: &mut dyn FnMut() -> TypeVar,
        gcx: &GlobalContext,
    ) -> Polytype {
        // Look up the type DefId by name
        let type_sym = gcx.interner.lookup(&self.type_name);
        let type_def_id = type_sym.and_then(|sym| gcx.definitions.get_by_symbol(sym).map(|d| d.id()));

        let result_ty = if let Some(def_id) = type_def_id {
            // Look up the List type constructor
            let list_sym = gcx.interner.lookup("List");
            let list_def_id = list_sym.and_then(|sym| gcx.definitions.get_by_symbol(sym).map(|d| d.id()));

            // Create Named type for the record type
            let record_ty = ir.types.alloc(IrType {
                loc: Loc::generated(),
                kind: IrTypeKind::Named(Ident::Resolved(def_id)),
            });

            if let Some(list_id) = list_def_id {
                // Return List<RecordType>
                ir.types.alloc(IrType {
                    loc: Loc::generated(),
                    kind: IrTypeKind::App {
                        ctor: Ident::Resolved(list_id),
                        args: vec![record_ty],
                    },
                })
            } else {
                // Fallback: just return the record type (shouldn't happen)
                record_ty
            }
        } else {
            // Fallback: use type variable if we can't find the type
            let t_var = _next_type_var();
            ir.types.alloc(IrType {
                loc: Loc::generated(),
                kind: IrTypeKind::Var(t_var),
            })
        };

        // Create function type: () -> List<RecordType>
        let fn_ty = ir.types.alloc(IrType {
            loc: Loc::generated(),
            kind: IrTypeKind::Function(vec![], result_ty),
        });

        Polytype::mono(fn_ty)
    }

    fn call(&self, _args: Vec<Value>, _ctx: &RuntimeContext) -> Result<Value, RuntimeError> {
        let config = self.config.clone();
        let schema = self.schema.clone();

        // Execute async query in the tokio runtime
        let rt = get_runtime();
        let result = rt.block_on(async {
            let pool = ConnectionPool::get_or_create(
                &config.connection_string,
                config.connect_timeout,
            ).await?;

            let query = config.source.to_query();
            execute_query_to_dataframe(&pool, &query, &schema).await
        });

        match result {
            Ok(df) => {
                // Convert DataFrame to LazyFrame for consistency with fossil's lazy evaluation model
                let lf = df.lazy();
                Ok(Value::Records(lf))
            }
            Err(e) => Err(RuntimeError::from(polars::prelude::PolarsError::ComputeError(
                format!("SQL query error: {}", e).into(),
            ))),
        }
    }
}

/// Query function for executing custom SQL queries with parameters
///
/// This is a more advanced function that allows runtime SQL execution.
/// Note: This exposes raw SQL execution and should be used carefully.
pub struct SqlQueryFunction {
    pub config: SqlConfig,
}

impl FunctionImpl for SqlQueryFunction {
    fn signature(
        &self,
        ir: &mut Ir,
        next_type_var: &mut dyn FnMut() -> TypeVar,
        _gcx: &GlobalContext,
    ) -> Polytype {
        // Signature: (String) -> List<Record>
        // Takes a SQL query string and returns results
        let string_ty = ir.types.alloc(IrType {
            loc: Loc::generated(),
            kind: IrTypeKind::Primitive(PrimitiveType::String),
        });

        let t_var = next_type_var();
        let result_ty = ir.types.alloc(IrType {
            loc: Loc::generated(),
            kind: IrTypeKind::Var(t_var),
        });

        let fn_ty = ir.types.alloc(IrType {
            loc: Loc::generated(),
            kind: IrTypeKind::Function(vec![string_ty], result_ty),
        });

        Polytype::poly(vec![t_var], fn_ty)
    }

    fn call(&self, args: Vec<Value>, _ctx: &RuntimeContext) -> Result<Value, RuntimeError> {
        let query_str = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::from(polars::prelude::PolarsError::ComputeError(
                    "SQL query function expects a string argument".into(),
                )));
            }
        };

        let config = self.config.clone();

        // Execute async query in the tokio runtime
        let rt = get_runtime();
        let result = rt.block_on(async {
            use super::schema::infer_schema;

            let pool = ConnectionPool::get_or_create(
                &config.connection_string,
                config.connect_timeout,
            ).await?;

            // Create a temporary config with the custom query
            let mut query_config = config.clone();
            query_config.source = super::config::SqlSource::Query(query_str.clone());

            // Infer schema from the query
            let schema = infer_schema(&query_config).await?;

            execute_query_to_dataframe(&pool, &query_str, &schema).await
        });

        match result {
            Ok(df) => {
                let lf = df.lazy();
                Ok(Value::Records(lf))
            }
            Err(e) => Err(RuntimeError::from(polars::prelude::PolarsError::ComputeError(
                format!("SQL query error: {}", e).into(),
            ))),
        }
    }
}
