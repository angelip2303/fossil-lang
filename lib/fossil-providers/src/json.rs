use std::fs::File;
use std::io::BufReader;
use std::num::NonZeroUsize;
use std::path::Path;
use std::sync::Arc;

use fossil_lang::ast::ast::{Literal, Ast, TypeKind, Type};
use fossil_lang::ast::thir::{TypedHir, Polytype, TypeVar, Type as ThirType, TypeKind as ThirTypeKind};
use fossil_lang::ast::Loc;
use fossil_lang::context::Interner;
use fossil_lang::error::{ProviderError, RuntimeError};
use fossil_lang::runtime::value::Value;
use fossil_lang::traits::function::{FunctionImpl, RuntimeContext};
use fossil_lang::traits::provider::{TypeProviderImpl, ProviderOutput, ModuleSpec, FunctionDef};
use polars::prelude::*;

use crate::utils::*;

pub struct JsonProvider;

impl TypeProviderImpl for JsonProvider {
    fn provide(
        &self,
        args: &[Literal],
        ast: &mut Ast,
        interner: &mut Interner,
    ) -> Result<ProviderOutput, ProviderError> {
        let path_str = extract_path_arg(args, interner)?;

        validate_extension(&path_str, &["json", "ndjson"], interner)?;
        validate_local_file(&path_str, interner)?;

        let path = Path::new(&path_str);
        let file = File::open(path)?;
        let reader = BufReader::new(file);

        let df = JsonReader::new(reader)
            .infer_schema_len(NonZeroUsize::new(100))
            .finish()?;

        let schema = df.schema();
        let fields = schema_to_ast_fields(&schema, ast, interner);

        // Create AST record type
        let record_ty = ast.types.alloc(Type {
            loc: fossil_lang::ast::Loc::generated(),
            kind: TypeKind::Record(fields),
        });

        // Generate module with load function
        let module_spec = ModuleSpec {
            functions: vec![
                FunctionDef {
                    name: "load".to_string(),
                    implementation: Arc::new(JsonLoadFunction {
                        file_path: path_str,
                        record_type: record_ty,
                    }),
                },
            ],
            submodules: vec![],
        };

        Ok(ProviderOutput {
            generated_type: record_ty,
            module_spec: Some(module_spec),
        })
    }
}

/// Load function for JSON files
///
/// This function is generated by the JSON provider and captures the file path
/// specified in the type provider invocation. At runtime, it loads the JSON
/// file as a LazyFrame without needing any arguments.
///
/// Example:
/// ```ignore
/// type Users = json<"users.json">
/// let data = Users::load()  // No arguments needed!
/// ```
pub struct JsonLoadFunction {
    file_path: String,
    record_type: fossil_lang::ast::ast::TypeId,
}

impl FunctionImpl for JsonLoadFunction {
    fn signature(&self, thir: &mut TypedHir, next_type_var: &mut dyn FnMut() -> TypeVar) -> Polytype {
        // Return a type variable that will be inferred
        let t_var = next_type_var();
        let result_ty = thir.types.alloc(ThirType {
            loc: Loc::generated(),
            kind: ThirTypeKind::Var(t_var),
        });

        Polytype::poly(vec![t_var], result_ty)
    }

    fn call(&self, _args: Vec<Value>, _ctx: &RuntimeContext) -> Result<Value, RuntimeError> {
        use fossil_lang::error::{CompileError, CompileErrorKind};

        // Load JSON as LazyFrame for lazy evaluation
        let path = Path::new(&self.file_path);
        let file = File::open(path).map_err(|e| {
            CompileError::new(
                CompileErrorKind::Runtime(format!("Failed to open JSON file: {}", e)),
                Loc::generated()
            )
        })?;
        let reader = BufReader::new(file);

        let df = JsonReader::new(reader)
            .infer_schema_len(NonZeroUsize::new(100))
            .finish()
            .map_err(|e| {
                CompileError::new(
                    CompileErrorKind::Runtime(format!("Failed to parse JSON file: {}", e)),
                    Loc::generated()
                )
            })?;

        Ok(Value::LazyFrame(df.lazy()))
    }
}
